day01QT框架学习 

#include<iostream>
#include<QDebug>
QPushButton * btn(对象名) = new QPushButton (新的对象)
qDebug() << "输出语句";




btn.show();
btn.setParent(this);
btn.move(int x, int y);//x轴坐标 y轴坐标
Widget.Fixedresize(int w， int h);//宽度weight、高度height

            QCreater
            /
           /
        Qwidget
        /    \
       /     \
       btn    MyButton
  //创建的时候由上往下进行new操作
  //点击“×”释放内存的时候是由先从下往上进行delect操作
  
  
  
  析构：
  在程序释放内存时，会可以构建析构从而在释放内存时先执行析构的内容然后再去执行。
  析构函数是特殊的类成员函数，简单来说，析构函数与构造函数的作用正好相反，它用来完成对象被删除前的一些清理工作，也就是专门的扫尾工作。如果构造函数打开了一个文件，最后不需要使用时文件就要被关闭，析构函数允许类自动完成类似清理工作，不必调用其他成员函数。
 按照这个逻辑在执行析构的顺序应该是先执行btn的析构，因为btn是最先被释放的，然后执行Qwidget的析构。
 逻辑没有错
 但是在执行析构的时候会先寻找对象树的祖先，从根节点开始执行，所以在执行析构时的顺序时跟new对象的顺序是一样的
 简而言之，在执行析构时会先执行Qwidget的析构，然后执行btn的析构函数。
 
 对象树
             QObeject
            /    |   \
           /     |   \
        QWidget   QWidget QWidget
        
  C++中规定了析构顺序应该按照其创建顺序的相反过程。那么问题来了，如果我们先创建了子对象，再创建的父对象，根据上述原理析构的时候先析构父对象，又因为Qt中的对象树自动析构原理，我们析构父对象会自动析构子对象。也就是说， 子对象此时就被析构了，然后代码继续执行，按照顺序还要再析构一次子对象，但是这时候已经是第二次调用 子对象的析构函数了，C++中不允许调用两次析构函数，因此，程序会崩溃。

 
 
 
 
 
 